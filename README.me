## Como funciona esto:

En router src/presentation/router/router.tsx se definen las URL de la interfaz, cada componente es el mismo de una p[a]gina creada.
En pages se crea la interfaz con la que se trabaja el frontend src/presentation/pages/index.ts segun cada interfaz se crea un folder y un archivo tsx 
En core/use-case se conecta al backend y obtiene la respuesta
En src/presentation/pages/paginaCasoDeUso/paginaCasoDeUso.tsx Se muestra en el frontend



<hr>
Decoder que se reemplaza por el reader en el stream:

Se puede ver en /Users/dev/Recursos/Apps/whatsappAPI/frontend/src/core/use-cases/prosConsStream.use-case.ts
         // const decoder = new TextDecoder();
        
                // let text = '';
        // while(true){
        //     // Aqui vamos a tomar 2 cosas del reader
        //     const {value, done} = await reader.read();
        //     // Cuando este el done, es decir cuando ya no hay mas informacion y se emitio nuestra respuesta
        //     // Esto va a otro ByteLengthQueuingStrategy, pero aqui src/core/use-cases/translateTextStream.use-case.ts permite ver los valores en consola
        //     if(done){
        //         break;
        //     }

        //     const decodedChunk = decoder.decode(value, {stream:true});
        //     text += decodedChunk;
        //     console.log(text)
        // }


<hr>

prosConsStreamGenerator.use-case.ts y prosConsStream.use-case hacen lo mismo.
prosConsStreamGenerator.use-case lo hace con una funcion generdadora de JS



Esto:
menuRoutes.map(option =>(
    <NavLink
        key={option.to}
        to={option.to}
        className= { ({isActive})=>
            isActive
                ? 'flex justify-center items-center bg-gray-800 rounded-md p-2 transition-colors'
                : 'flex justify-center items-center hover:bg-gray-800 rounded-md p-2 transition-colors'
        }
    >
        <i className={`${option.icon} text-2xl mr-4 text-indigo-400`}></i>
        <div className="flex flex-col flex-grow">
            <span className="text-white text-lg font-semibold">
                {option.title}
            </span>
            <span className="text-gray-400 text-sm">
                {option.description}
            </span>
        </div>

    </NavLink>
))

Queda asi:
menuRoutes.map(option =>(
<SidebarMenuItem to={option.to} icon={option.icon} title={option.title} description={option.description} />
            ))

Y esto lo dejo asi:
menuRoutes.map(option =>(
                <SidebarMenuItem key={option.to} {...option} />
            ))