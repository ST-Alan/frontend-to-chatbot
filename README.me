## Como funciona esto:

0.- Configuracion
En router src/presentation/router/router.tsx se definen las URL de la interfaz, cada componente es el mismo de una p[a]gina creada en: src/presentation/pages
En pages se crea la interfaz con la que se trabaja el frontend src/presentation/pages/index.ts segun cada interfaz se crea un folder y un archivo tsx 
En src/core/use-case se conecta al backend y obtiene la respuesta
La respuesta se envia a src/presentation/pages/paginaDelCasoDeUso/
En src/presentation/pages/paginaDelCasoDeUso/paginaDelCasoDeUso.tsx Se muestra en el frontend

En src/presentation/template/Chat-template.tsx esta la plantilla de la interfaz de mensaje. Se copia en cada pagina y se adapta
En src/presentation/components/chat-input-boxes estan los diversosn inputs para enviar el prompt, puede ser con archivo, seleccionando una opcion o un mensaje de texto plano

En las paginas:
1.- El handlepost->  const handlePost = async(text:string) recibe el texto, cuando hay audio, recibe el audio, cuando hay imagenes lo mismo.
Cuando son idiomas recibe el prompt mas el idioma. 
En general el handlepost recibe todo lo que se vaya a enviar desde el chat


2.- El input puede tener el accept que especifica los formatos aceptados en el envio de lo que se escribe
    <TextMessageBoxFile
      onSendMessage={handlePost}
      placeHolder="Escribe aqui tu mensaje"
      disableCorrections
      accept=""
    />

En este caso el TextMessageBoxFile se llama de src/presentation/components/chat-input-boxes/TextMessageBoxFile.tsx, entonces se agrega en ese archivo para poder usarlo

El input en src/presentation/components/chat-input-boxes/TextMessageBoxFile.tsx, este aceptar esta en:

<input
    type="file"
    ref={inputFileRef}
    accept={accept}
    //Aca es posible agregar un muiltiselect
    onChange={(e)=>setSelectedFile(e.target.files?.item(0))}
    hidden
/>




<hr>
Decoder que se reemplaza por el reader en el stream:

Se puede ver en /Users/dev/Recursos/Apps/whatsappAPI/frontend/src/core/use-cases/prosConsStream.use-case.ts
         // const decoder = new TextDecoder();
        
                // let text = '';
        // while(true){
        //     // Aqui vamos a tomar 2 cosas del reader
        //     const {value, done} = await reader.read();
        //     // Cuando este el done, es decir cuando ya no hay mas informacion y se emitio nuestra respuesta
        //     // Esto va a otro ByteLengthQueuingStrategy, pero aqui src/core/use-cases/translateTextStream.use-case.ts permite ver los valores en consola
        //     if(done){
        //         break;
        //     }

        //     const decodedChunk = decoder.decode(value, {stream:true});
        //     text += decodedChunk;
        //     console.log(text)
        // }


<hr>

prosConsStreamGenerator.use-case.ts y prosConsStream.use-case hacen lo mismo.
prosConsStreamGenerator.use-case lo hace con una funcion generdadora de JS



Esto:
menuRoutes.map(option =>(
    <NavLink
        key={option.to}
        to={option.to}
        className= { ({isActive})=>
            isActive
                ? 'flex justify-center items-center bg-gray-800 rounded-md p-2 transition-colors'
                : 'flex justify-center items-center hover:bg-gray-800 rounded-md p-2 transition-colors'
        }
    >
        <i className={`${option.icon} text-2xl mr-4 text-indigo-400`}></i>
        <div className="flex flex-col flex-grow">
            <span className="text-white text-lg font-semibold">
                {option.title}
            </span>
            <span className="text-gray-400 text-sm">
                {option.description}
            </span>
        </div>

    </NavLink>
))

Queda asi:
menuRoutes.map(option =>(
<SidebarMenuItem to={option.to} icon={option.icon} title={option.title} description={option.description} />
            ))

Y esto lo dejo asi:
menuRoutes.map(option =>(
                <SidebarMenuItem key={option.to} {...option} />
            ))